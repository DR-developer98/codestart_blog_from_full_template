{{}} ===> variabelen
Wanneer de engine van de template deze haakjes tegenkomt, 
dan zal hij deze als variabel evalueren en de inhoud door het resultaat
vervangen.

{{post.author}} zal vervangen worden door de waarde van "author" van het 
post-object.




{%%} ===> Dit noemen we een "tag". 
Deze zijn complexer dan variabelen. 
Sommige staan toe dat er tekts of HTML-code ertussen wordt gepropt.
Sommige anderen, zoals de "for" loop controleren de flow d.m.v. 
performing loops.



{% for post in post_list %} ===> Een "for" loop heeft iets nodig om over te itereren.
In dit geval gaat het om het post_list-object.
Dit object is doorgegeven aan de template door de generic ListView,
en bevat de contents van de queryset die we eerder hebben gedefinieerd.
"post_list" stamt uit de modelnaam (Post) en het viewtype (ListView)
Deze naam wordt automatisch door Django gegenereerd.


{% if forloop.counter|divisibleby:3 %} ==>Het if-statement checkt hoe veel keer een "for" loop gerund heeft.
Als de teller deelbaar door drie is, dan zal het een bijkomende afsluitende <div> tag toevoegen en een nieuwe 
openings- <div> tag met de klasse "row".
Dit is om ervoor te zorgen dat we een maximaal van 3 posts per regel hebben.


{% url 'home' as home_url %}
Dit is een tag ==> de url-tag verwijst naar een absolute path reference, d.w.z. een url gespeend van de domeinnaam.
Waar komt 'home' vandaan? Als we een kijkje nemen in blog/urls.py, zien we in het pad naar onze main view de naam "home" heeft.
Wat gebeurt hier verder? 
De url "home" wordt toegewezen aan de home_url variabel.

<a class="nav-link
  ***{% if request.path == home_url %}active{% endif %}***"
  aria-current="page" href="#">
Dit if statement vergelijkt request.path (huidige url) met "home_url".
Indien deze gelijk zijn, dan krijgt de <a> tag de klasse "active".

Wat is "request.path"? 
Zoals we gezien hebben, is een view een functie die verzoeken aanneemt en een Http Response retourneert.
"request" is een object met ook een path property.
"request.path" is een string, die het volledige pad naar de verzochte pagina weergeeft, maar dan zonder domeinnaam.
Klinkt bekend? Dit is precies wat de {%% url %%} tag doet. "home" is de url zonder de domeinnaam.

Waarom hebben we ditniet kunnen doen?
Was veel minder ingewikkeld en vooral veel sneller geweest.

{% if request.path == {% url 'home' %} %}

Dit komt doordat we een tag niet ingesloten kan worden door een andere tag.
Daarom hebben we de url 'home' aan een variabel moeten toewijzen.

{% if request.path == home_url %}active{% endif %}

{% endif %} ==> verplicht in Django als afsluitende tag van een {% if %} statement
{% endfor %} ==> verplicht in Django als afsluitende tag van een {% for %} loop.




<a class="nav-link {% if request.path == home_url %}active{% endif %}" aria-current="page"
    href="****{% url 'home' %}****">Home</a>

{% url 'home' %} ==> Dit is hoe je een link aan een navbar <a> toevoegt d.m.v. de Django url tag
